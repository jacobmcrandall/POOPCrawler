using System;
using System.Collections.Generic;
using System.IO;
using CocosSharp;
using Microsoft.Xna.Framework;

namespace DungEon
{
    /*
        TODO : Implement character, player and enemy classes
        implement a checkSurroundingTies method
            - Checks surrounding tiles for a property name and value (north south east west) - return a list of these tile coordinates
        - check that this works

        add in useItem and armor once weapon/item is done (start simpler)

        -fixup maps so if walkable only the walkable tiles are on the map layer - ie don't cover ENTIRE map in walkable tiles - only the walkable bits

    */

    /*
    general stuff / explanations of confusing stuff
    TILEMAPS : A tile map contains what's called a "TileLayersContainer" which holds layers of maps
    so in level 1 for example there are 3 layers, a layer for the ground, a layer for water, and a layer for objects, like the door and user
    tiles don't exist in the map they exist in the tile layers container which is basically a list of layers that hold tiles
    so to interact with tiles do a foreach layer in tilelayerscontainer OR do a TileMap.LayerNamed("LayerName") to get a reference to a layer

    COORDINATES : There is a difference between WORLD coordinates and TILECOORDINATES - tile cooridnates are like row 5, column 3
    world coordinates are by pixel - so sometimes we have to translate between the two
    generally if you need to reference a tile use tilecoordinates - when interacting with objects ON tiles or touches use WORLD coordinates
    check touchlistener for some examples of this
    */
    public class GameLayer : CCTileMap
    {
        static int numLevels = 2; //The number of levels that we have - we load a level 1 through numLevels randomly
        CCEventListenerTouchAllAtOnce touchListener;
        character user = null; // start off as null - looptiles will spawn

        //TODO - populate and manage a list of all enemies on the stage - map has a property called "numEnemies" to spawn that many enemies randomly
        List<character> enemiesList = null;

        public GameLayer() : base("level_" + CCRandom.GetRandomInt(1, numLevels) + ".tmx") // get a random level and load it on initialization
        {
            //touch listener - calles tileHandler to handle tile touches
            touchListener = new CCEventListenerTouchAllAtOnce();
            touchListener.OnTouchesEnded = handleEndTouches;
            AddEventListener(touchListener);

            //Schedule the main game loop
            Schedule(RunGameLogic);
        }

        //Handle all touches
        void handleEndTouches(System.Collections.Generic.List<CCTouch> touches, CCEvent touchEvent)
        {
            var touchLocation = touches[0].Location; //get our touch location in WORLD coords
            foreach (CCTileMapLayer layer in TileLayersContainer.Children) // check every layer that was touched
            {
                var tileCoordinates = layer.ClosestTileCoordAtNodePosition(touchLocation); //get the closest tile to our touch
                var world = layer.TilePosition(tileCoordinates); //translate this tile to WORLD coordinates
                //Console.WriteLine("Row : " + tileCoordinates.Row + " Column: " + tileCoordinates.Column);

                //Center our coordinates to the center of our tile
                world = new CCPoint(world.X + TileTexelSize.Width / 2, world.Y + TileTexelSize.Width / 2);
                tileHandler(world, layer);
            }

        }

        void RunGameLogic(float frameTimeInSeconds)
        {
            loopTiles();
            //TODO - foreach enemy in user list - call move one random && call check for user && call attack if user is there
            //TODO - call user.MoveOne() - for each item in an array of moveOne calls - generated by our path finding algorithm
        }

        //Calls the tileHandler on EVERY map tile
        void loopTiles()
        {
            int tileDimension = (int)TileTexelSize.Width;
            int numberOfColumns = (int)MapDimensions.Size.Width;
            int numberOfRows = (int)MapDimensions.Size.Height;
            CCPointI world = new CCPointI(0, 0);
            // Tile maps can have multiple layers, so let's loop through all of them:
            foreach (CCTileMapLayer layer in TileLayersContainer.Children)
            {
                // Loop through the columns and rows to find all tiles
                for (int column = 0; column < numberOfColumns; column++)
                {
                    // We're going to add tileDimension / 2 to get the position
                    // of the center of the tile - this will help us in 
                    // positioning entities, and will eliminate the possibility
                    // of floating point error when calculating the nearest tile:
                    world.X = tileDimension * column + tileDimension / 2;
                    for (int row = 0; row < numberOfRows; row++)
                    {
                        // See above on why we add tileDimension / 2
                        world.Y = tileDimension * row + tileDimension / 2;
                        tileHandler(world, layer,true);
                    }
                }
            }
        }

        //Handles individual tiles at individual layers
        //Some things shouldn't be done by the loop such as exiting the game - so use the calledByLoop to differentiate between the two
        //if this gets messy could split this function into two for each use
        void tileHandler(CCPoint world, CCTileMapLayer layer, Boolean calledByLoop=false)
        {
            CCTileMapCoordinates tileAtXy = layer.ClosestTileCoordAtNodePosition(world); // get tile coordinates corresponding to our touch location
            CCTileGidAndFlags info = layer.TileGIDAndFlags(tileAtXy.Column, tileAtXy.Row);
            //Tilemaps made in the "tiled" program can hold properties - get the properties of the tile
            Dictionary<string, string> properties = TilePropertiesForGID(info.Gid); 

            //Clicking a walkable tile
            if (!calledByLoop && properties != null && properties.ContainsKey("walkable") && properties["walkable"] == "true")
            {
                // Console.WriteLine("You clicked a walkable tile");
                user.move(world);
            }
            //Spawning in the user - only happens once - not called by user
            if (user == null && calledByLoop && properties != null && properties.ContainsKey("name") && properties["name"] == "spawn")
            {
                user = new character("userChar",20,world,this);
                layer.AddChild(user);
            }
            //Exiting the map
            //TODO - add more checks here - such as all enemies dead && user on exit portal 
            //-- currently for testing just does this automatically
            if (!calledByLoop && properties != null && properties.ContainsKey("name") && properties["name"] == "exit")
            {
                Console.WriteLine("Adding random map");
                GameLayer.getNewMap(GameView);
            }
        }

        //Adds a random tilemap - call this to load a new level
        public static void getNewMap(CCGameView gameView)
        {
            CCScene gamePlayScene = new CCScene(gameView);
            gamePlayScene.AddLayer(new GameLayer());
            gameView.Director.ReplaceScene(gamePlayScene);

            
        }

        //add items to scene here
        protected override void AddedToScene()
        {
            //Sets our screen size appropriately
            GameView.DesignResolution = new CCSizeI(
                                          (int)(MapDimensions.Size.Width * TileTexelSize.Height)
                                        , (int)(MapDimensions.Size.Height * TileTexelSize.Height));
            base.AddedToScene();
        }
        public static CCScene GameScene(CCGameView mainWindow)
        {
            var scene = new CCScene(mainWindow);
            var layer = new GameLayer();
            scene.AddChild(layer);

            return scene;
        }
    }
}
